#include <math.h>
#ifdef __USE_CMSIS
#include "LPC8xx.h"
#include "lpc8xx_clkconfig.h"
#include "lpc8xx_mrt.h"
#endif

#include <cr_section_macros.h>

#define CLOCK_SYSOSC_30MHZ

static inline void SwitchMatrix_Init()
{	/* Generated by the Switch Matric Tool */

	/* Enable SWM clock (already enabled in system_LPC8xx.c */
	//LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);

	/* Pin Assign 8 bit Configuration */
	/* U0_TXD */
	/* U0_RXD */
	LPC_SWM->PINASSIGN0 = 0xffff0004UL;
	/* CTOUT_0 */
	LPC_SWM->PINASSIGN6 = 0x07ffffffUL;
	/* CTOUT_1 */
	/* CTOUT_2 */
	/* I2C0_SDA */
	LPC_SWM->PINASSIGN7 = 0x0aff1011UL;
	/* I2C0_SCL */
	LPC_SWM->PINASSIGN8 = 0xffffff0bUL;

	/* Pin Assign 1 bit Configuration */
	/* SWCLK */
	/* SWDIO */
	/* XTALIN */
	/* XTALOUT */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffff83UL;

	/* Disable the clock to the Switch Matrix to save power */
	LPC_SYSCON->SYSAHBCLKCTRL &= ~(1<<7);
}

#if defined(CLOCK_SYSOSC_30MHZ)
static inline void IOCON_Init()
{	/* Generated by the Switch Matric Tool */

	/* Enable IOCON clock (already enabled in system_LPC8xx.c) */
	//LPC_SYSCON->SYSAHBCLKCTRL |= (1<<18);

	/* Pin I/O Configuration */
	/* LPC_IOCON->PIO0_0 = 0x90; */
	/* LPC_IOCON->PIO0_1 = 0x90; */
	/* LPC_IOCON->PIO0_2 = 0x90; */
	/* LPC_IOCON->PIO0_3 = 0x90; */
	/* LPC_IOCON->PIO0_4 = 0x90; */
	/* LPC_IOCON->PIO0_5 = 0x90; */
	/* LPC_IOCON->PIO0_6 = 0x90; */
	/* LPC_IOCON->PIO0_7 = 0x90; */
	// Enable XTALIN and XTALOUT on PIO0_8 and PIO0_9 & remove the pull-up/down resistors
	LPC_IOCON->PIO0_8 = 0x80;
	LPC_IOCON->PIO0_9 = 0x80;
	/* LPC_IOCON->PIO0_10 = 0x80; */
	/* LPC_IOCON->PIO0_11 = 0x80; */
	/* LPC_IOCON->PIO0_12 = 0x90; */
	/* LPC_IOCON->PIO0_13 = 0x90; */
	/* LPC_IOCON->PIO0_14 = 0x90; */
	/* LPC_IOCON->PIO0_15 = 0x90; */
	/* LPC_IOCON->PIO0_16 = 0x90; */
	/* LPC_IOCON->PIO0_17 = 0x90; */

	/* Disable the clock to the IOCON to save power */
	LPC_SYSCON->SYSAHBCLKCTRL &= ~(1<<18);
}

static inline void Clock_Setup()
{	/* Reconfigure 30MHz system clock derived from System oscillator */
	/* Set up PLL: */
	//   Power up the crystal oscillator & system PLL in the PDRUNCFG register
	LPC_SYSCON->PDRUNCFG &= ~((1 << 5) | (1 << 7));
	//   Select the PLL input in the SYSPLLCLKSEL register
	LPC_SYSCON->SYSPLLCLKSEL = 1;	/* SYSOSC */
	//   Update the PLL clock source in the SYSPLLCLKUEN register
	LPC_SYSCON->SYSPLLCLKUEN = 0;
	LPC_SYSCON->SYSPLLCLKUEN = 1;
	//   Configure the PLL M and N dividers
	LPC_SYSCON->SYSPLLCTRL = (4 | (1 << 5));
	//   Wait for the PLL to lock by monitoring the PLL lock status
	while (!(LPC_SYSCON->SYSPLLSTAT & 1));

	/* Configure the main clock and system clock: */
	//   Select the main clock
	LPC_SYSCON->MAINCLKSEL = 3;		/* PLL output */
	//   Update the main clock source
	LPC_SYSCON->MAINCLKUEN = 0;
	LPC_SYSCON->MAINCLKUEN = 1;
	//   Select the divider value for the system clock to core, memories, and peripherals
	LPC_SYSCON->SYSAHBCLKDIV = 1;

	// Disable the BYPASS bit and select the oscillator frequency range in SYSOSCCTRL register
	LPC_SYSCON->SYSOSCCTRL = 0;
}

#define SCT_PRESCALER			30		// Prescale the 30MHz OSC to 1MHz SCT clock
#else
#define SCT_PRESCALER			12		// Prescale the 12MHz IRC to 1MHz SCT clock
#endif
#define SCT_LIMIT_50HZ			20000	// Set SCT outputs every 20ms (50Hz)
#define SCT_MATCH_RED			1000	// Match for 1ms pulse
#define SCT_MATCH_GREEN			1500	// Match for 1.5ms pulse
#define SCT_MATCH_BLUE			2000	// Match for 2ms pulse

static void SCT_Setup()
{
	// Enable the clock to the SCT register	interface and peripheral clock
	LPC_SYSCON->SYSAHBCLKCTRL |= (1 << 8);
	// Clear the SCT peripheral reset
	LPC_SYSCON->PRESETCTRL |= (1 << 8);

	// Set up the SCT as one unified 32-bit reload timer, no auto limit
	LPC_SCT->CONFIG = 0x00000001;
	// Set the prescaled factor, clear and halt the counter
	LPC_SCT->CTRL_U = ((SCT_PRESCALER - 1) << 5) | (1 << 3) | (1 << 2);
	// Optional preload the unified timer with a count value to LPC_SCT->COUNT_U
	// Configure match/limit registers
	// Create match events and optional interrupts on those match events
	// Connect CTOUTn pins to match events
	LPC_SCT->REGMODE_L  = 0;
	LPC_SCT->LIMIT_L    = 0x10;		// Use MAT4 as count limit
	LPC_SCT->MATCH[4].U = LPC_SCT->MATCHREL[4].U = (SCT_LIMIT_50HZ - 1);
	LPC_SCT->EVENT[4].STATE = 1,
	LPC_SCT->EVENT[4].CTRL  = 0x1004;

	LPC_SCT->MATCH[0].U = LPC_SCT->MATCHREL[0].U = (SCT_MATCH_RED - 1);
	LPC_SCT->EVENT[0].STATE = 1,
	LPC_SCT->EVENT[0].CTRL  = 0x1000;
	LPC_SCT->OUT[0].SET = 0x10;
	LPC_SCT->OUT[0].CLR = 0x01;

	LPC_SCT->MATCH[1].U = LPC_SCT->MATCHREL[1].U = (SCT_MATCH_GREEN - 1);
	LPC_SCT->EVENT[1].STATE = 1,
	LPC_SCT->EVENT[1].CTRL  = 0x1001;
	LPC_SCT->OUT[1].SET = 0x10;
	LPC_SCT->OUT[1].CLR = 0x02;

	LPC_SCT->MATCH[2].U = LPC_SCT->MATCHREL[2].U = (SCT_MATCH_BLUE - 1);
	LPC_SCT->EVENT[2].STATE = 1,
	LPC_SCT->EVENT[2].CTRL  = 0x1002;
	LPC_SCT->OUT[2].SET = 0x10;
	LPC_SCT->OUT[2].CLR = 0x04;

	// Start the counter
	LPC_SCT->CTRL_U &= ~(1 << 2);
}

#if defined(CLOCK_SYSOSC_30MHZ)
#define MRT_INTVAL_100MS		(30000 * 100)
#else
#define MRT_INTVAL_100MS		(12000 * 100)
#endif
#define MATCH_AMPLITUDE			((SCT_LIMIT_50HZ - 1) >> 1)

int main(void)
{
	SwitchMatrix_Init();
#if defined(CLOCK_SYSOSC_30MHZ)
	IOCON_Init();
	Clock_Setup();
#endif
	SCT_Setup();
	init_mrt(MRT_INTVAL_100MS);

	const double PI = 3.14159;
	extern volatile uint32_t mrt_counter;
	while(1) {
		__WFI();
		LPC_SCT->MATCHREL[0].U = MATCH_AMPLITUDE * (sin(mrt_counter * PI / 180) + 1);
		LPC_SCT->MATCHREL[1].U = MATCH_AMPLITUDE * (cos((mrt_counter >> 1) * PI / 180) + 1);
		LPC_SCT->MATCHREL[2].U = MATCH_AMPLITUDE * (cos((mrt_counter >> 2) * PI / 180) + 1);
	}
	return 0 ;
}
